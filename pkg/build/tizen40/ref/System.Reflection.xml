<?xml version="1.0" encoding="utf-8"?><span>
<doc>
  <assembly>
    <name>System.Reflection</name>
  </assembly>
  <members>
    <member name="T:System.Reflection.AmbiguousMatchException">
      <summary>The exception that is thrown when binding to a member results in more than one member matching the binding criteria. This class cannot be inherited.</summary>
    </member>
    <member name="M:System.Reflection.AmbiguousMatchException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.AmbiguousMatchException"></see> class with an empty message string and the root cause exception set to null.</summary>
    </member>
    <member name="M:System.Reflection.AmbiguousMatchException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.AmbiguousMatchException"></see> class with its message string set to the given message and the root cause exception set to null.</summary>
      <param name="message">A string indicating the reason this exception was thrown.</param>
    </member>
    <member name="M:System.Reflection.AmbiguousMatchException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.AmbiguousMatchException"></see> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="inner">The exception that is the cause of the current exception. If the inner parameter is not null, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="T:System.Reflection.Assembly">
      <summary>Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</summary>
    </member>
    <member name="P:System.Reflection.Assembly.CodeBase">
      <summary>Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName"></see> object.</summary>
      <returns>The location of the assembly as specified originally.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.CreateInstance(System.String)">
      <summary>Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</summary>
      <param name="typeName">The <see cref="P:System.Type.FullName"></see> of the type to locate.</param>
      <returns>An instance of the specified type created with the default constructor; or null if <paramref name="typeName">typeName</paramref> is not found. The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags"></see> set to Public or Instance.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="typeName">typeName</paramref> is an empty string (&quot;&quot;) or a string beginning with a null character.   -or-   The current assembly was loaded into the reflection-only context.</exception>
      <exception cref="T:System.ArgumentNullException"><paramref name="typeName">typeName</paramref> is null.</exception>
      <exception cref="T:System.MissingMethodException">No matching constructor was found.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName">typeName</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><paramref name="typeName">typeName</paramref> requires a dependent assembly that was found but could not be loaded.   -or-   The current assembly was loaded into the reflection-only context, and <paramref name="typeName">typeName</paramref> requires a dependent assembly that was not preloaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="typeName">typeName</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="typeName">typeName</paramref> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)">
      <summary>Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</summary>
      <param name="typeName">The <see cref="P:System.Type.FullName"></see> of the type to locate.</param>
      <param name="ignoreCase">true to ignore the case of the type name; otherwise, false.</param>
      <returns>An instance of the specified type created with the default constructor; or null if <paramref name="typeName">typeName</paramref> is not found. The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags"></see> set to Public or Instance.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="typeName">typeName</paramref> is an empty string (&quot;&quot;) or a string beginning with a null character.   -or-   The current assembly was loaded into the reflection-only context.</exception>
      <exception cref="T:System.MissingMethodException">No matching constructor was found.</exception>
      <exception cref="T:System.ArgumentNullException"><paramref name="typeName">typeName</paramref> is null.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName">typeName</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><paramref name="typeName">typeName</paramref> requires a dependent assembly that was found but could not be loaded.   -or-   The current assembly was loaded into the reflection-only context, and <paramref name="typeName">typeName</paramref> requires a dependent assembly that was not preloaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="typeName">typeName</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="typeName">typeName</paramref> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)">
      <summary>Creates the name of a type qualified by the display name of its assembly.</summary>
      <param name="assemblyName">The display name of an assembly.</param>
      <param name="typeName">The full name of a type.</param>
      <returns>The full name of the type qualified by the display name of the assembly.</returns>
    </member>
    <member name="P:System.Reflection.Assembly.CustomAttributes">
      <summary>Gets a collection that contains this assembly's custom attributes.</summary>
      <returns>A collection that contains this assembly's custom attributes.</returns>
    </member>
    <member name="P:System.Reflection.Assembly.DefinedTypes">
      <summary>Gets a collection of the types defined in this assembly.</summary>
      <returns>A collection of the types defined in this assembly.</returns>
    </member>
    <member name="P:System.Reflection.Assembly.EntryPoint">
      <summary>Gets the entry point of this assembly.</summary>
      <returns>An object that represents the entry point of this assembly. If no entry point is found (for example, the assembly is a DLL), null is returned.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.Equals(System.Object)">
      <summary>Determines whether this assembly and the specified object are equal.</summary>
      <param name="o">The object to compare with this instance.</param>
      <returns>true if <paramref name="o">o</paramref> is equal to this instance; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.Assembly.ExportedTypes">
      <summary>Gets a collection of the public types defined in this assembly that are visible outside the assembly.</summary>
      <returns>A collection of the public types defined in this assembly that are visible outside the assembly.</returns>
    </member>
    <member name="P:System.Reflection.Assembly.FullName">
      <summary>Gets the display name of the assembly.</summary>
      <returns>The display name of the assembly.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.GetEntryAssembly">
      <summary>Gets the process executable in the default application domain. In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)"></see>.</summary>
      <returns>The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)"></see>. Can return null when called from unmanaged code.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.GetExportedTypes">
      <summary>Gets the public types defined in this assembly that are visible outside the assembly.</summary>
      <returns>An array that represents the types defined in this assembly that are visible outside the assembly.</returns>
      <exception cref="T:System.NotSupportedException">The assembly is a dynamic assembly.</exception>
    </member>
    <member name="M:System.Reflection.Assembly.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)">
      <summary>Returns information about how the given resource has been persisted.</summary>
      <param name="resourceName">The case-sensitive name of the resource.</param>
      <returns>An object that is populated with information about the resource's topology, or null if the resource is not found.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="resourceName">resourceName</paramref> is null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="resourceName">resourceName</paramref> parameter is an empty string (&quot;&quot;).</exception>
    </member>
    <member name="M:System.Reflection.Assembly.GetManifestResourceNames">
      <summary>Returns the names of all the resources in this assembly.</summary>
      <returns>An array that contains the names of all the resources.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)">
      <summary>Loads the specified manifest resource from this assembly.</summary>
      <param name="name">The case-sensitive name of the manifest resource being requested.</param>
      <returns>The manifest resource; or null if no resources were specified during compilation or if the resource is not visible to the caller.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="name">name</paramref> parameter is null.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="name">name</paramref> parameter is an empty string (&quot;&quot;).</exception>
      <exception cref="T:System.IO.FileLoadException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException"></see>, instead.  

 A file that was found could not be loaded.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="name">name</paramref> was not found.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="name">name</paramref> is not a valid assembly.</exception>
      <exception cref="T:System.NotImplementedException">Resource length is greater than <see cref="F:System.Int64.MaxValue"></see>.</exception>
    </member>
    <member name="M:System.Reflection.Assembly.GetName">
      <summary>Gets an <see cref="T:System.Reflection.AssemblyName"></see> for this assembly.</summary>
      <returns>An object that contains the fully parsed display name for this assembly.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.GetReferencedAssemblies">
      <summary>Gets the <see cref="T:System.Reflection.AssemblyName"></see> objects for all the assemblies referenced by this assembly.</summary>
      <returns>An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)">
      <summary>Gets the <see cref="T:System.Type"></see> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</summary>
      <param name="name">The full name of the type.</param>
      <param name="throwOnError">true to throw an exception if the type is not found; false to return null.</param>
      <returns>An object that represents the specified class.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="name">name</paramref> is invalid.   -or-   The length of <paramref name="name">name</paramref> exceeds 1024 characters.</exception>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
      <exception cref="T:System.TypeLoadException"><paramref name="throwOnError">throwOnError</paramref> is true, and the type cannot be found.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="name">name</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><paramref name="name">name</paramref> requires a dependent assembly that was found but could not be loaded.   -or-   The current assembly was loaded into the reflection-only context, and <paramref name="name">name</paramref> requires a dependent assembly that was not preloaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="name">name</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="name">name</paramref> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Gets the <see cref="T:System.Type"></see> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</summary>
      <param name="name">The full name of the type.</param>
      <param name="throwOnError">true to throw an exception if the type is not found; false to return null.</param>
      <param name="ignoreCase">true to ignore the case of the type name; otherwise, false.</param>
      <returns>An object that represents the specified class.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="name">name</paramref> is invalid.   -or-   The length of <paramref name="name">name</paramref> exceeds 1024 characters.</exception>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
      <exception cref="T:System.TypeLoadException"><paramref name="throwOnError">throwOnError</paramref> is true, and the type cannot be found.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="name">name</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><paramref name="name">name</paramref> requires a dependent assembly that was found but could not be loaded.   -or-   The current assembly was loaded into the reflection-only context, and <paramref name="name">name</paramref> requires a dependent assembly that was not preloaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="name">name</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="name">name</paramref> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Assembly.GetType(System.String)">
      <summary>Gets the <see cref="T:System.Type"></see> object with the specified name in the assembly instance.</summary>
      <param name="name">The full name of the type.</param>
      <returns>An object that represents the specified class, or null if the class is not found.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="name">name</paramref> is invalid.</exception>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="name">name</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><p sourcefile="System.Reflection.yml" sourcestartlinenumber="1" sourceendlinenumber="3"><block subset="none" type="note">
      <p><br> In the <a href="http://go.microsoft.com/fwlink/?LinkID=247912" data-raw-source="[.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912)" sourcefile="System.Reflection.yml" sourcestartlinenumber="3" sourceendlinenumber="3">.NET for Windows Store apps</a> or the <a href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md" data-raw-source="[Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)" sourcefile="System.Reflection.yml" sourcestartlinenumber="3" sourceendlinenumber="3">Portable Class Library</a>, catch the base class exception, <xref href="System.IO.IOException"></xref>, instead.  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="5" sourceendlinenumber="7">
    </block>
    <code data-dev-comment-type="paramref">name</code> requires a dependent assembly that was found but could not be loaded.  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="9" sourceendlinenumber="9"> -or-  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="11" sourceendlinenumber="11"> The current assembly was loaded into the reflection-only context, and <code data-dev-comment-type="paramref">name</code> requires a dependent assembly that was not preloaded.</p>
</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="name">name</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="name">name</paramref> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Assembly.GetTypes">
      <summary>Gets the types defined in this assembly.</summary>
      <returns>An array that contains all the types that are defined in this assembly.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">The assembly contains one or more types that cannot be loaded. The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types"></see> property of this exception contains a <see cref="T:System.Type"></see> object for each type that was loaded and null for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions"></see> property contains an exception for each type that could not be loaded.</exception>
    </member>
    <member name="P:System.Reflection.Assembly.ImageRuntimeVersion">
      <summary>Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</summary>
      <returns>The CLR version folder name. This is not a full path.</returns>
    </member>
    <member name="P:System.Reflection.Assembly.IsDynamic">
      <summary>Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</summary>
      <returns>true if the current assembly was generated dynamically in the current process; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)">
      <summary>Loads an assembly given its <see cref="T:System.Reflection.AssemblyName"></see>.</summary>
      <param name="assemblyRef">The object that describes the assembly to be loaded.</param>
      <returns>The loaded assembly.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef">assemblyRef</paramref> is null.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef">assemblyRef</paramref> is not found.</exception>
      <exception cref="T:System.IO.FileLoadException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException"></see>, instead.  

 A file that was found could not be loaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef">assemblyRef</paramref> is not a valid assembly. -or-   Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef">assemblyRef</paramref> was compiled with a later version.</exception>
    </member>
    <member name="P:System.Reflection.Assembly.Location">
      <summary>Gets the full path or UNC location of the loaded file that contains the manifest.</summary>
      <returns>The location of the loaded file that contains the manifest. If the loaded file was shadow-copied, the location is that of the file after being shadow-copied. If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])"></see> method overload, the value returned is an empty string (&quot;&quot;).</returns>
      <exception cref="T:System.NotSupportedException">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder"></see> object.</exception>
    </member>
    <member name="P:System.Reflection.Assembly.ManifestModule">
      <summary>Gets the module that contains the manifest for the current assembly.</summary>
      <returns>The module that contains the manifest for the assembly.</returns>
    </member>
    <member name="P:System.Reflection.Assembly.Modules">
      <summary>Gets a collection that contains the modules in this assembly.</summary>
      <returns>A collection that contains the modules in this assembly.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.ToString">
      <summary>Returns the full name of the assembly, also known as the display name.</summary>
      <returns>The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</returns>
    </member>
    <member name="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)">
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.AssemblyContentType">
      <summary>Provides information about the type of code contained in an assembly.</summary>
    </member>
    <member name="F:System.Reflection.AssemblyContentType.Default">
      <summary>The assembly contains .NET Framework code.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.AssemblyContentType.WindowsRuntime">
      <summary>The assembly contains Windows Runtime code.</summary>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.AssemblyName">
      <summary>Describes an assembly's unique identity in full.</summary>
    </member>
    <member name="M:System.Reflection.AssemblyName.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName"></see> class.</summary>
    </member>
    <member name="M:System.Reflection.AssemblyName.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.AssemblyName"></see> class with the specified display name.</summary>
      <param name="assemblyName">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName"></see> property.</param>
      <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName">assemblyName</paramref> is null.</exception>
      <exception cref="T:System.ArgumentException"><paramref name="assemblyName">assemblyName</paramref> is a zero length string.</exception>
      <exception cref="T:System.IO.FileLoadException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException"></see>, instead.  

 The referenced assembly could not be found, or could not be loaded.</exception>
    </member>
    <member name="P:System.Reflection.AssemblyName.ContentType">
      <summary>Gets or sets a value that indicates what type of content the assembly contains.</summary>
      <returns>A value that indicates what type of content the assembly contains.</returns>
    </member>
    <member name="P:System.Reflection.AssemblyName.CultureName">
      <summary>Gets or sets the name of the culture associated with the assembly.</summary>
      <returns>The culture name.</returns>
    </member>
    <member name="P:System.Reflection.AssemblyName.Flags">
      <summary>Gets or sets the attributes of the assembly.</summary>
      <returns>A value that represents the attributes of the assembly.</returns>
    </member>
    <member name="P:System.Reflection.AssemblyName.FullName">
      <summary>Gets the full name of the assembly, also known as the display name.</summary>
      <returns>A string that is the full name of the assembly, also known as the display name.</returns>
    </member>
    <member name="M:System.Reflection.AssemblyName.GetPublicKey">
      <summary>Gets the public key of the assembly.</summary>
      <returns>A byte array that contains the public key of the assembly.</returns>
      <exception cref="T:System.Security.SecurityException">A public key was provided (for example, by using the <see cref="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])"></see> method), but no public key token was provided.</exception>
    </member>
    <member name="M:System.Reflection.AssemblyName.GetPublicKeyToken">
      <summary>Gets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</summary>
      <returns>A byte array that contains the public key token.</returns>
    </member>
    <member name="P:System.Reflection.AssemblyName.Name">
      <summary>Gets or sets the simple name of the assembly. This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.</summary>
      <returns>The simple name of the assembly.</returns>
    </member>
    <member name="P:System.Reflection.AssemblyName.ProcessorArchitecture">
      <summary>Gets or sets a value that identifies the processor and bits-per-word of the platform targeted by an executable.</summary>
      <returns>One of the enumeration values that identifies the processor and bits-per-word of the platform targeted by an executable.</returns>
    </member>
    <member name="M:System.Reflection.AssemblyName.SetPublicKey(System.Byte[])">
      <summary>Sets the public key identifying the assembly.</summary>
      <param name="publicKey">A byte array containing the public key of the assembly.</param>
    </member>
    <member name="M:System.Reflection.AssemblyName.SetPublicKeyToken(System.Byte[])">
      <summary>Sets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</summary>
      <param name="publicKeyToken">A byte array containing the public key token of the assembly.</param>
    </member>
    <member name="M:System.Reflection.AssemblyName.ToString">
      <summary>Returns the full name of the assembly, also known as the display name.</summary>
      <returns>The full name of the assembly, or the class name if the full name cannot be determined.</returns>
    </member>
    <member name="P:System.Reflection.AssemblyName.Version">
      <summary>Gets or sets the major, minor, build, and revision numbers of the assembly.</summary>
      <returns>An object that represents the major, minor, build, and revision numbers of the assembly.</returns>
    </member>
    <member name="T:System.Reflection.BindingFlags">
      <summary>Specifies flags that control binding and the way in which the search for members and types is conducted by reflection.</summary>
    </member>
    <member name="F:System.Reflection.BindingFlags.CreateInstance">
      <summary>Specifies that reflection should create an instance of the specified type. Calls the constructor that matches the given arguments. The supplied member name is ignored. If the type of lookup is not specified, (Instance | Public) will apply. It is not possible to call a type initializer.   This flag is passed to an InvokeMember method to invoke a constructor.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.DeclaredOnly">
      <summary>Specifies that only members declared at the level of the supplied type's hierarchy should be considered. Inherited members are not considered.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.Default">
      <summary>Specifies that no binding flags are defined.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.FlattenHierarchy">
      <summary>Specifies that public and protected static members up the hierarchy should be returned. Private static members in inherited classes are not returned. Static members include fields, methods, events, and properties. Nested types are not returned.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.GetField">
      <summary>Specifies that the value of the specified field should be returned.   This flag is passed to an InvokeMember method to get a field value.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.GetProperty">
      <summary>Specifies that the value of the specified property should be returned.   This flag is passed to an InvokeMember method to invoke a property getter.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.IgnoreCase">
      <summary>Specifies that the case of the member name should not be considered when binding.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.Instance">
      <summary>Specifies that instance members are to be included in the search.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.InvokeMethod">
      <summary>Specifies that a method is to be invoked. This must not be a constructor or a type initializer.   This flag is passed to an InvokeMember method to invoke a method.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.NonPublic">
      <summary>Specifies that non-public members are to be included in the search.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.Public">
      <summary>Specifies that public members are to be included in the search.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.SetField">
      <summary>Specifies that the value of the specified field should be set.   This flag is passed to an InvokeMember method to set a field value.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.SetProperty">
      <summary>Specifies that the value of the specified property should be set. For COM properties, specifying this binding flag is equivalent to specifying PutDispProperty and PutRefDispProperty.   This flag is passed to an InvokeMember method to invoke a property setter.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.BindingFlags.Static">
      <summary>Specifies that static members are to be included in the search.</summary>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.ConstructorInfo">
      <summary>Discovers the attributes of a class constructor and provides access to constructor metadata.</summary>
    </member>
    <member name="F:System.Reflection.ConstructorInfo.ConstructorName">
      <summary>Represents the name of the class constructor method as it is stored in metadata. This name is always &quot;.ctor&quot;. This field is read-only.</summary>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.ConstructorInfo.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.ConstructorInfo.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.ConstructorInfo.Invoke(System.Object[])">
      <summary>Invokes the constructor reflected by the instance that has the specified parameters, providing default values for the parameters not commonly used.</summary>
      <param name="parameters">An array of values that matches the number, order and type (under the constraints of the default binder) of the parameters for this constructor. If this constructor takes no parameters, then use either an array with zero elements or null, as in Object[] parameters = new Object[0]. Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is null. For value-type elements, this value is 0, 0.0, or false, depending on the specific element type.</param>
      <returns>An instance of the class associated with the constructor.</returns>
      <exception cref="T:System.MemberAccessException">The class is abstract.   -or-   The constructor is a class initializer.</exception>
      <exception cref="T:System.MethodAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 The constructor is private or protected, and the caller lacks <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess"></see>.</exception>
      <exception cref="T:System.ArgumentException">The <paramref name="parameters">parameters</paramref> array does not contain values that match the types accepted by this constructor.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">The invoked constructor throws an exception.</exception>
      <exception cref="T:System.Reflection.TargetParameterCountException">An incorrect number of parameters was passed.</exception>
      <exception cref="T:System.NotSupportedException">Creation of <see cref="T:System.TypedReference"></see>, <see cref="T:System.ArgIterator"></see>, and <see cref="T:System.RuntimeArgumentHandle"></see> types is not supported.</exception>
      <exception cref="T:System.Security.SecurityException">The caller does not have the necessary code access permission.</exception>
    </member>
    <member name="P:System.Reflection.ConstructorInfo.MemberType">
      <summary>Gets a <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a constructor.</summary>
      <returns>A <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a constructor.</returns>
    </member>
    <member name="F:System.Reflection.ConstructorInfo.TypeConstructorName">
      <summary>Represents the name of the type constructor method as it is stored in metadata. This name is always &quot;.cctor&quot;. This property is read-only.</summary>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.CustomAttributeData">
      <summary>Provides access to custom attribute data for assemblies, modules, types, members and parameters that are loaded into the reflection-only context.</summary>
    </member>
    <member name="P:System.Reflection.CustomAttributeData.AttributeType">
      <summary>Gets the type of the attribute.</summary>
      <returns>The type of the attribute.</returns>
    </member>
    <member name="P:System.Reflection.CustomAttributeData.Constructor">
      <summary>Gets a <see cref="T:System.Reflection.ConstructorInfo"></see> object that represents the constructor that would have initialized the custom attribute.</summary>
      <returns>An object that represents the constructor that would have initialized the custom attribute represented by the current instance of the <see cref="T:System.Reflection.CustomAttributeData"></see> class.</returns>
    </member>
    <member name="P:System.Reflection.CustomAttributeData.ConstructorArguments">
      <summary>Gets the list of positional arguments specified for the attribute instance represented by the <see cref="T:System.Reflection.CustomAttributeData"></see> object.</summary>
      <returns>A collection of structures that represent the positional arguments specified for the custom attribute instance.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeData.GetCustomAttributes(System.Reflection.Assembly)">
      <summary>Returns a list of <see cref="T:System.Reflection.CustomAttributeData"></see> objects representing data about the attributes that have been applied to the target assembly.</summary>
      <param name="target">The assembly whose custom attribute data is to be retrieved.</param>
      <returns>A list of objects that represent data about the attributes that have been applied to the target assembly.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="target">target</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.CustomAttributeData.GetCustomAttributes(System.Reflection.MemberInfo)">
      <summary>Returns a list of <see cref="T:System.Reflection.CustomAttributeData"></see> objects representing data about the attributes that have been applied to the target member.</summary>
      <param name="target">The member whose attribute data is to be retrieved.</param>
      <returns>A list of objects that represent data about the attributes that have been applied to the target member.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="target">target</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.CustomAttributeData.GetCustomAttributes(System.Reflection.Module)">
      <summary>Returns a list of <see cref="T:System.Reflection.CustomAttributeData"></see> objects representing data about the attributes that have been applied to the target module.</summary>
      <param name="target">The module whose custom attribute data is to be retrieved.</param>
      <returns>A list of objects that represent data about the attributes that have been applied to the target module.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="target">target</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.CustomAttributeData.GetCustomAttributes(System.Reflection.ParameterInfo)">
      <summary>Returns a list of <see cref="T:System.Reflection.CustomAttributeData"></see> objects representing data about the attributes that have been applied to the target parameter.</summary>
      <param name="target">The parameter whose attribute data is to be retrieved.</param>
      <returns>A list of objects that represent data about the attributes that have been applied to the target parameter.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="target">target</paramref> is null.</exception>
    </member>
    <member name="P:System.Reflection.CustomAttributeData.NamedArguments">
      <summary>Gets the list of named arguments specified for the attribute instance represented by the <see cref="T:System.Reflection.CustomAttributeData"></see> object.</summary>
      <returns>A collection of structures that represent the named arguments specified for the custom attribute instance.</returns>
    </member>
    <member name="T:System.Reflection.CustomAttributeNamedArgument">
      <summary>Represents a named argument of a custom attribute in the reflection-only context.</summary>
    </member>
    <member name="M:System.Reflection.CustomAttributeNamedArgument.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeNamedArgument.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="P:System.Reflection.CustomAttributeNamedArgument.IsField">
      <summary>Gets a value that indicates whether the named argument is a field.</summary>
      <returns>true if the named argument is a field; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.CustomAttributeNamedArgument.MemberName">
      <summary>Gets the name of the attribute member that would be used to set the named argument.</summary>
      <returns>The name of the attribute member that would be used to set the named argument.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeNamedArgument.op_Equality(System.Reflection.CustomAttributeNamedArgument,System.Reflection.CustomAttributeNamedArgument)">
      <summary>Tests whether two <see cref="T:System.Reflection.CustomAttributeNamedArgument"></see> structures are equivalent.</summary>
      <param name="left">The structure to the left of the equality operator.</param>
      <param name="right">The structure to the right of the equality operator.</param>
      <returns>true if the two <see cref="T:System.Reflection.CustomAttributeNamedArgument"></see> structures are equal; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeNamedArgument.op_Inequality(System.Reflection.CustomAttributeNamedArgument,System.Reflection.CustomAttributeNamedArgument)">
      <summary>Tests whether two <see cref="T:System.Reflection.CustomAttributeNamedArgument"></see> structures are different.</summary>
      <param name="left">The structure to the left of the inequality operator.</param>
      <param name="right">The structure to the right of the inequality operator.</param>
      <returns>true if the two <see cref="T:System.Reflection.CustomAttributeNamedArgument"></see> structures are different; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeNamedArgument.ToString">
      <summary>Returns a string that consists of the argument name, the equal sign, and a string representation of the argument value.</summary>
      <returns>A string that consists of the argument name, the equal sign, and a string representation of the argument value.</returns>
    </member>
    <member name="P:System.Reflection.CustomAttributeNamedArgument.TypedValue">
      <summary>Gets a <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structure that can be used to obtain the type and value of the current named argument.</summary>
      <returns>A structure that can be used to obtain the type and value of the current named argument.</returns>
    </member>
    <member name="T:System.Reflection.CustomAttributeTypedArgument">
      <summary>Represents an argument of a custom attribute in the reflection-only context, or an element of an array argument.</summary>
    </member>
    <member name="P:System.Reflection.CustomAttributeTypedArgument.ArgumentType">
      <summary>Gets the type of the argument or of the array argument element.</summary>
      <returns>A <see cref="T:System.Type"></see> object representing the type of the argument or of the array element.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeTypedArgument.Equals(System.Object)">
      <summary>Indicates whether this instance and a specified object are equal.</summary>
      <param name="obj">Another object to compare to.</param>
      <returns>true if <paramref name="obj">obj</paramref> and this instance are the same type and represent the same value; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeTypedArgument.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeTypedArgument.op_Equality(System.Reflection.CustomAttributeTypedArgument,System.Reflection.CustomAttributeTypedArgument)">
      <summary>Tests whether two <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structures are equivalent.</summary>
      <param name="left">The <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structure to the left of the equality operator.</param>
      <param name="right">The <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structure to the right of the equality operator.</param>
      <returns>true if the two <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structures are equal; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeTypedArgument.op_Inequality(System.Reflection.CustomAttributeTypedArgument,System.Reflection.CustomAttributeTypedArgument)">
      <summary>Tests whether two <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structures are different.</summary>
      <param name="left">The <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structure to the left of the inequality operator.</param>
      <param name="right">The <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structure to the right of the inequality operator.</param>
      <returns>true if the two <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> structures are different; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.CustomAttributeTypedArgument.ToString">
      <summary>Returns a string consisting of the argument name, the equal sign, and a string representation of the argument value.</summary>
      <returns>A string consisting of the argument name, the equal sign, and a string representation of the argument value.</returns>
    </member>
    <member name="P:System.Reflection.CustomAttributeTypedArgument.Value">
      <summary>Gets the value of the argument for a simple argument or for an element of an array argument; gets a collection of values for an array argument.</summary>
      <returns>An object that represents the value of the argument or element, or a generic <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"></see> of <see cref="T:System.Reflection.CustomAttributeTypedArgument"></see> objects that represent the values of an array-type argument.</returns>
    </member>
    <member name="T:System.Reflection.EventInfo">
      <summary>Discovers the attributes of an event and provides access to event metadata.</summary>
    </member>
    <member name="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)">
      <summary>Adds an event handler to an event source.</summary>
      <param name="target">The event source.</param>
      <param name="handler">Encapsulates a method or methods to be invoked when the event is raised by the target.</param>
      <exception cref="T:System.InvalidOperationException">The event does not have a public add accessor.</exception>
      <exception cref="T:System.ArgumentException">The handler that was passed in cannot be used.</exception>
      <exception cref="T:System.MethodAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 The caller does not have access permission to the member.</exception>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception"></see> instead.  

 The <paramref name="target">target</paramref> parameter is null and the event is not static.   -or-   The <see cref="T:System.Reflection.EventInfo"></see> is not declared on the target.</exception>
    </member>
    <member name="P:System.Reflection.EventInfo.AddMethod">
      <summary>Gets the <see cref="T:System.Reflection.MethodInfo"></see> object for the <see cref="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)"></see> method of the event, including non-public methods.</summary>
      <returns>The <see cref="T:System.Reflection.MethodInfo"></see> object for the <see cref="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)"></see> method.</returns>
    </member>
    <member name="P:System.Reflection.EventInfo.Attributes">
      <summary>Gets the attributes for this event.</summary>
      <returns>The read-only attributes for this event.</returns>
    </member>
    <member name="M:System.Reflection.EventInfo.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.EventInfo.EventHandlerType">
      <summary>Gets the Type object of the underlying event-handler delegate associated with this event.</summary>
      <returns>A read-only Type object representing the delegate event handler.</returns>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
    </member>
    <member name="M:System.Reflection.EventInfo.GetAddMethod">
      <summary>Returns the method used to add an event handler delegate to the event source.</summary>
      <returns>A <see cref="T:System.Reflection.MethodInfo"></see> object representing the method used to add an event handler delegate to the event source.</returns>
    </member>
    <member name="M:System.Reflection.EventInfo.GetAddMethod(System.Boolean)">
      <summary>When overridden in a derived class, retrieves the MethodInfo object for the <see cref="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)"></see> method of the event, specifying whether to return non-public methods.</summary>
      <param name="nonPublic">true if non-public methods can be returned; otherwise, false.</param>
      <returns>A <see cref="T:System.Reflection.MethodInfo"></see> object representing the method used to add an event handler delegate to the event source.</returns>
      <exception cref="T:System.MethodAccessException"><paramref name="nonPublic">nonPublic</paramref> is true, the method used to add an event handler delegate is non-public, and the caller does not have permission to reflect on non-public methods.</exception>
    </member>
    <member name="M:System.Reflection.EventInfo.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.EventInfo.GetRaiseMethod">
      <summary>Returns the method that is called when the event is raised.</summary>
      <returns>The method that is called when the event is raised.</returns>
    </member>
    <member name="M:System.Reflection.EventInfo.GetRaiseMethod(System.Boolean)">
      <summary>When overridden in a derived class, returns the method that is called when the event is raised, specifying whether to return non-public methods.</summary>
      <param name="nonPublic">true if non-public methods can be returned; otherwise, false.</param>
      <returns>A MethodInfo object that was called when the event was raised.</returns>
      <exception cref="T:System.MethodAccessException"><paramref name="nonPublic">nonPublic</paramref> is true, the method used to add an event handler delegate is non-public, and the caller does not have permission to reflect on non-public methods.</exception>
    </member>
    <member name="M:System.Reflection.EventInfo.GetRemoveMethod(System.Boolean)">
      <summary>When overridden in a derived class, retrieves the MethodInfo object for removing a method of the event, specifying whether to return non-public methods.</summary>
      <param name="nonPublic">true if non-public methods can be returned; otherwise, false.</param>
      <returns>A <see cref="T:System.Reflection.MethodInfo"></see> object representing the method used to remove an event handler delegate from the event source.</returns>
      <exception cref="T:System.MethodAccessException"><paramref name="nonPublic">nonPublic</paramref> is true, the method used to add an event handler delegate is non-public, and the caller does not have permission to reflect on non-public methods.</exception>
    </member>
    <member name="M:System.Reflection.EventInfo.GetRemoveMethod">
      <summary>Returns the method used to remove an event handler delegate from the event source.</summary>
      <returns>A <see cref="T:System.Reflection.MethodInfo"></see> object representing the method used to remove an event handler delegate from the event source.</returns>
    </member>
    <member name="P:System.Reflection.EventInfo.IsMulticast">
      <summary>Gets a value indicating whether the event is multicast.</summary>
      <returns>true if the delegate is an instance of a multicast delegate; otherwise, false.</returns>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
    </member>
    <member name="P:System.Reflection.EventInfo.IsSpecialName">
      <summary>Gets a value indicating whether the EventInfo has a name with a special meaning.</summary>
      <returns>true if this event has a special name; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.EventInfo.MemberType">
      <summary>Gets a <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is an event.</summary>
      <returns>A <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is an event.</returns>
    </member>
    <member name="P:System.Reflection.EventInfo.RaiseMethod">
      <summary>Gets the method that is called when the event is raised, including non-public methods.</summary>
      <returns>The method that is called when the event is raised.</returns>
    </member>
    <member name="M:System.Reflection.EventInfo.RemoveEventHandler(System.Object,System.Delegate)">
      <summary>Removes an event handler from an event source.</summary>
      <param name="target">The event source.</param>
      <param name="handler">The delegate to be disassociated from the events raised by target.</param>
      <exception cref="T:System.InvalidOperationException">The event does not have a public remove accessor.</exception>
      <exception cref="T:System.ArgumentException">The handler that was passed in cannot be used.</exception>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception"></see> instead.  

 The <paramref name="target">target</paramref> parameter is null and the event is not static.   -or-   The <see cref="T:System.Reflection.EventInfo"></see> is not declared on the target.</exception>
      <exception cref="T:System.MethodAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 The caller does not have access permission to the member.</exception>
    </member>
    <member name="P:System.Reflection.EventInfo.RemoveMethod">
      <summary>Gets the MethodInfo object for removing a method of the event, including non-public methods.</summary>
      <returns>The MethodInfo object for removing a method of the event.</returns>
    </member>
    <member name="T:System.Reflection.FieldInfo">
      <summary>Discovers the attributes of a field and provides access to field metadata.</summary>
    </member>
    <member name="P:System.Reflection.FieldInfo.Attributes">
      <summary>Gets the attributes associated with this field.</summary>
      <returns>The FieldAttributes for this field.</returns>
    </member>
    <member name="M:System.Reflection.FieldInfo.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.FieldType">
      <summary>Gets the type of this field object.</summary>
      <returns>The type of this field object.</returns>
    </member>
    <member name="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)">
      <summary>Gets a <see cref="T:System.Reflection.FieldInfo"></see> for the field represented by the specified handle.</summary>
      <param name="handle">A <see cref="T:System.RuntimeFieldHandle"></see> structure that contains the handle to the internal metadata representation of a field.</param>
      <returns>A <see cref="T:System.Reflection.FieldInfo"></see> object representing the field specified by <paramref name="handle">handle</paramref>.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="handle">handle</paramref> is invalid.</exception>
    </member>
    <member name="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)">
      <summary>Gets a <see cref="T:System.Reflection.FieldInfo"></see> for the field represented by the specified handle, for the specified generic type.</summary>
      <param name="handle">A <see cref="T:System.RuntimeFieldHandle"></see> structure that contains the handle to the internal metadata representation of a field.</param>
      <param name="declaringType">A <see cref="T:System.RuntimeTypeHandle"></see> structure that contains the handle to the generic type that defines the field.</param>
      <returns>A <see cref="T:System.Reflection.FieldInfo"></see> object representing the field specified by <paramref name="handle">handle</paramref>, in the generic type specified by <paramref name="declaringType">declaringType</paramref>.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="handle">handle</paramref> is invalid.   -or-  <paramref name="declaringType">declaringType</paramref> is not compatible with <paramref name="handle">handle</paramref>. For example, <paramref name="declaringType">declaringType</paramref> is the runtime type handle of the generic type definition, and <paramref name="handle">handle</paramref> comes from a constructed type.</exception>
    </member>
    <member name="M:System.Reflection.FieldInfo.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers">
      <summary>Gets an array of types that identify the optional custom modifiers of the field.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that identify the optional custom modifiers of the current field, such as <see cref="T:System.Runtime.CompilerServices.IsConst"></see>.</returns>
    </member>
    <member name="M:System.Reflection.FieldInfo.GetRawConstantValue">
      <summary>Returns a literal value associated with the field by a compiler.</summary>
      <returns>An <see cref="T:System.Object"></see> that contains the literal value associated with the field. If the literal value is a class type with an element value of zero, the return value is null.</returns>
      <exception cref="T:System.InvalidOperationException">The Constant table in unmanaged metadata does not contain a constant value for the current field.</exception>
      <exception cref="T:System.FormatException">The type of the value is not one of the types permitted by the Common Language Specification (CLS). See the ECMA Partition II specification Metadata Logical Format: Other Structures, Element Types used in Signatures.</exception>
      <exception cref="T:System.NotSupportedException">The constant value for the field is not set.</exception>
    </member>
    <member name="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers">
      <summary>Gets an array of types that identify the required custom modifiers of the property.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that identify the required custom modifiers of the current property, such as <see cref="T:System.Runtime.CompilerServices.IsConst"></see> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced"></see>.</returns>
    </member>
    <member name="M:System.Reflection.FieldInfo.GetValue(System.Object)">
      <summary>When overridden in a derived class, returns the value of a field supported by a given object.</summary>
      <param name="obj">The object whose field value will be returned.</param>
      <returns>An object containing the value of the field reflected by this instance.</returns>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the Portable Class Library, catch <see cref="T:System.Exception"></see> instead.  

 The field is non-static and <paramref name="obj">obj</paramref> is null.</exception>
      <exception cref="T:System.NotSupportedException">A field is marked literal, but the field does not have one of the accepted literal types.</exception>
      <exception cref="T:System.FieldAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the Portable Class Library, catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 The caller does not have permission to access this field.</exception>
      <exception cref="T:System.ArgumentException">The method is neither declared nor inherited by the class of <paramref name="obj">obj</paramref>.</exception>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsAssembly">
      <summary>Gets a value indicating whether the potential visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.Assembly"></see>; that is, the field is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</summary>
      <returns>true if the visibility of this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.Assembly"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsFamily">
      <summary>Gets a value indicating whether the visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.Family"></see>; that is, the field is visible only within its class and derived classes.</summary>
      <returns>true if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.Family"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsFamilyAndAssembly">
      <summary>Gets a value indicating whether the visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.FamANDAssem"></see>; that is, the field can be accessed from derived classes, but only if they are in the same assembly.</summary>
      <returns>true if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.FamANDAssem"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsFamilyOrAssembly">
      <summary>Gets a value indicating whether the potential visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.FamORAssem"></see>; that is, the field can be accessed by derived classes wherever they are, and by classes in the same assembly.</summary>
      <returns>true if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.FamORAssem"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsInitOnly">
      <summary>Gets a value indicating whether the field can only be set in the body of the constructor.</summary>
      <returns>true if the field has the InitOnly attribute set; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsLiteral">
      <summary>Gets a value indicating whether the value is written at compile time and cannot be changed.</summary>
      <returns>true if the field has the Literal attribute set; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsPrivate">
      <summary>Gets a value indicating whether the field is private.</summary>
      <returns>true if the field is private; otherwise; false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsPublic">
      <summary>Gets a value indicating whether the field is public.</summary>
      <returns>true if this field is public; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsSpecialName">
      <summary>Gets a value indicating whether the corresponding SpecialName attribute is set in the <see cref="T:System.Reflection.FieldAttributes"></see> enumerator.</summary>
      <returns>true if the SpecialName attribute is set in <see cref="T:System.Reflection.FieldAttributes"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.IsStatic">
      <summary>Gets a value indicating whether the field is static.</summary>
      <returns>true if this field is static; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.FieldInfo.MemberType">
      <summary>Gets a <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a field.</summary>
      <returns>A <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a field.</returns>
    </member>
    <member name="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)">
      <summary>Sets the value of the field supported by the given object.</summary>
      <param name="obj">The object whose field value will be set.</param>
      <param name="value">The value to assign to the field.</param>
      <exception cref="T:System.FieldAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 The caller does not have permission to access this field.</exception>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception"></see> instead.  

 The <paramref name="obj">obj</paramref> parameter is null and the field is an instance field.</exception>
      <exception cref="T:System.ArgumentException">The field does not exist on the object.   -or-   The <paramref name="value">value</paramref> parameter cannot be converted and stored in the field.</exception>
    </member>
    <member name="T:System.Reflection.ICustomAttributeProvider">
      <summary>Provides custom attributes for reflection objects that support them.</summary>
    </member>
    <member name="M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)">
      <summary>Returns an array of all of the custom attributes defined on this member, excluding named attributes, or an empty array if there are no custom attributes.</summary>
      <param name="inherit">When true, look up the hierarchy chain for the inherited custom attribute.</param>
      <returns>An array of Objects representing custom attributes, or an empty array.</returns>
      <exception cref="T:System.TypeLoadException">The custom attribute type cannot be loaded.</exception>
      <exception cref="T:System.Reflection.AmbiguousMatchException">There is more than one attribute of type <paramref name="attributeType">attributeType</paramref> defined on this member.</exception>
    </member>
    <member name="M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)">
      <summary>Returns an array of custom attributes defined on this member, identified by type, or an empty array if there are no custom attributes of that type.</summary>
      <param name="attributeType">The type of the custom attributes.</param>
      <param name="inherit">When true, look up the hierarchy chain for the inherited custom attribute.</param>
      <returns>An array of Objects representing custom attributes, or an empty array.</returns>
      <exception cref="T:System.TypeLoadException">The custom attribute type cannot be loaded.</exception>
      <exception cref="T:System.ArgumentNullException"><paramref name="attributeType">attributeType</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)">
      <summary>Indicates whether one or more instance of <paramref name="attributeType">attributeType</paramref> is defined on this member.</summary>
      <param name="attributeType">The type of the custom attributes.</param>
      <param name="inherit">When true, look up the hierarchy chain for the inherited custom attribute.</param>
      <returns>true if the <paramref name="attributeType">attributeType</paramref> is defined on this member; false otherwise.</returns>
    </member>
    <member name="T:System.Reflection.IntrospectionExtensions">
      <summary>Contains methods for converting <see cref="T:System.Type"></see> objects.</summary>
    </member>
    <member name="M:System.Reflection.IntrospectionExtensions.GetTypeInfo(System.Type)">
      <summary>Returns the <see cref="T:System.Reflection.TypeInfo"></see> representation of the specified type.</summary>
      <param name="type">The type to convert.</param>
      <returns>The converted object.</returns>
    </member>
    <member name="T:System.Reflection.InvalidFilterCriteriaException">
      <summary>The exception that is thrown in <see cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)"></see> when the filter criteria is not valid for the type of filter you are using.</summary>
    </member>
    <member name="M:System.Reflection.InvalidFilterCriteriaException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.InvalidFilterCriteriaException"></see> class with the default properties.</summary>
    </member>
    <member name="M:System.Reflection.InvalidFilterCriteriaException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.InvalidFilterCriteriaException"></see> class with the given HRESULT and message string.</summary>
      <param name="message">The message text for the exception.</param>
    </member>
    <member name="M:System.Reflection.InvalidFilterCriteriaException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.InvalidFilterCriteriaException"></see> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="inner">The exception that is the cause of the current exception. If the inner parameter is not null, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="T:System.Reflection.IReflectableType">
      <summary>Represents a type that you can reflect over.</summary>
    </member>
    <member name="M:System.Reflection.IReflectableType.GetTypeInfo">
      <summary>Retrieves an object that represents this type.</summary>
      <returns>An object that represents this type.</returns>
    </member>
    <member name="T:System.Reflection.LocalVariableInfo">
      <summary>Discovers the attributes of a local variable and provides access to local variable metadata.</summary>
    </member>
    <member name="M:System.Reflection.LocalVariableInfo.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.LocalVariableInfo"></see> class.</summary>
    </member>
    <member name="P:System.Reflection.LocalVariableInfo.IsPinned">
      <summary>Gets a <see cref="T:System.Boolean"></see> value that indicates whether the object referred to by the local variable is pinned in memory.</summary>
      <returns>true if the object referred to by the variable is pinned in memory; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.LocalVariableInfo.LocalIndex">
      <summary>Gets the index of the local variable within the method body.</summary>
      <returns>An integer value that represents the order of declaration of the local variable within the method body.</returns>
    </member>
    <member name="P:System.Reflection.LocalVariableInfo.LocalType">
      <summary>Gets the type of the local variable.</summary>
      <returns>The type of the local variable.</returns>
    </member>
    <member name="M:System.Reflection.LocalVariableInfo.ToString">
      <summary>Returns a user-readable string that describes the local variable.</summary>
      <returns>A string that displays information about the local variable, including the type name, index, and pinned status.</returns>
    </member>
    <member name="T:System.Reflection.ManifestResourceInfo">
      <summary>Provides access to manifest resources, which are XML files that describe application dependencies.</summary>
    </member>
    <member name="M:System.Reflection.ManifestResourceInfo.#ctor(System.Reflection.Assembly,System.String,System.Reflection.ResourceLocation)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.ManifestResourceInfo"></see> class for a resource that is contained by the specified assembly and file, and that has the specified location.</summary>
      <param name="containingAssembly">The assembly that contains the manifest resource.</param>
      <param name="containingFileName">The name of the file that contains the manifest resource, if the file is not the same as the manifest file.</param>
      <param name="resourceLocation">A bitwise combination of enumeration values that provides information about the location of the manifest resource.</param>
    </member>
    <member name="P:System.Reflection.ManifestResourceInfo.FileName">
      <summary>Gets the name of the file that contains the manifest resource, if it is not the same as the manifest file.</summary>
      <returns>The manifest resource's file name.</returns>
    </member>
    <member name="P:System.Reflection.ManifestResourceInfo.ReferencedAssembly">
      <summary>Gets the containing assembly for the manifest resource.</summary>
      <returns>The manifest resource's containing assembly.</returns>
    </member>
    <member name="P:System.Reflection.ManifestResourceInfo.ResourceLocation">
      <summary>Gets the manifest resource's location.</summary>
      <returns>A bitwise combination of <see cref="T:System.Reflection.ResourceLocation"></see> flags that indicates the location of the manifest resource.</returns>
    </member>
    <member name="T:System.Reflection.MemberFilter">
      <summary>Represents a delegate that is used to filter a list of members represented in an array of <see cref="T:System.Reflection.MemberInfo"></see> objects.</summary>
      <param name="m">The <see cref="T:System.Reflection.MemberInfo"></see> object to which the filter is applied.</param>
      <param name="filterCriteria">An arbitrary object used to filter the list.</param>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.MemberInfo">
      <summary>Obtains information about the attributes of a member and provides access to member metadata.</summary>
    </member>
    <member name="P:System.Reflection.MemberInfo.CustomAttributes">
      <summary>Gets a collection that contains this member's custom attributes.</summary>
      <returns>A collection that contains this member's custom attributes.</returns>
    </member>
    <member name="P:System.Reflection.MemberInfo.DeclaringType">
      <summary>Gets the class that declares this member.</summary>
      <returns>The Type object for the class that declares this member.</returns>
    </member>
    <member name="M:System.Reflection.MemberInfo.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.MemberInfo.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="P:System.Reflection.MemberInfo.MemberType">
      <summary>When overridden in a derived class, gets a <see cref="T:System.Reflection.MemberTypes"></see> value indicating the type of the member — method, constructor, event, and so on.</summary>
      <returns>A <see cref="T:System.Reflection.MemberTypes"></see> value indicating the type of member.</returns>
    </member>
    <member name="P:System.Reflection.MemberInfo.MetadataToken">
      <summary>Gets a value that identifies a metadata element.</summary>
      <returns>A value which, in combination with <see cref="P:System.Reflection.MemberInfo.Module"></see>, uniquely identifies a metadata element.</returns>
      <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Reflection.MemberInfo"></see> represents an array method, such as Address, on an array type whose element type is a dynamic type that has not been completed. To get a metadata token in this case, pass the <see cref="T:System.Reflection.MemberInfo"></see> object to the <see cref="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)"></see> method; or use the <see cref="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])"></see> method to get the token directly, instead of using the <see cref="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])"></see> method to get a <see cref="T:System.Reflection.MethodInfo"></see> first.</exception>
    </member>
    <member name="P:System.Reflection.MemberInfo.Module">
      <summary>Gets the module in which the type that declares the member represented by the current <see cref="T:System.Reflection.MemberInfo"></see> is defined.</summary>
      <returns>The <see cref="T:System.Reflection.Module"></see> in which the type that declares the member represented by the current <see cref="T:System.Reflection.MemberInfo"></see> is defined.</returns>
      <exception cref="T:System.NotImplementedException">This method is not implemented.</exception>
    </member>
    <member name="P:System.Reflection.MemberInfo.Name">
      <summary>Gets the name of the current member.</summary>
      <returns>A <see cref="T:System.String"></see> containing the name of this member.</returns>
    </member>
    <member name="M:System.Reflection.MemberInfo.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)">
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.MemberInfo.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.MemberInfo.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.MemberTypes">
      <summary>Marks each type of member that is defined as a derived class of <see cref="T:System.Reflection.MemberInfo"></see>.</summary>
    </member>
    <member name="F:System.Reflection.MemberTypes.All">
      <summary>Specifies all member types.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.Constructor">
      <summary>Specifies that the member is a constructor</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.Custom">
      <summary>Specifies that the member is a custom member type.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.Event">
      <summary>Specifies that the member is an event.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.Field">
      <summary>Specifies that the member is a field.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.Method">
      <summary>Specifies that the member is a method.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.NestedType">
      <summary>Specifies that the member is a nested type.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.Property">
      <summary>Specifies that the member is a property.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.MemberTypes.TypeInfo">
      <summary>Specifies that the member is a type.</summary>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.MethodBase">
      <summary>Provides information about methods and constructors.</summary>
    </member>
    <member name="P:System.Reflection.MethodBase.Attributes">
      <summary>Gets the attributes associated with this method.</summary>
      <returns>One of the <see cref="T:System.Reflection.MethodAttributes"></see> values.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.CallingConvention">
      <summary>Gets a value indicating the calling conventions for this method.</summary>
      <returns>The <see cref="T:System.Reflection.CallingConventions"></see> for this method.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.ContainsGenericParameters">
      <summary>Gets a value indicating whether the generic method contains unassigned generic type parameters.</summary>
      <returns>true if the current <see cref="T:System.Reflection.MethodBase"></see> object represents a generic method that contains unassigned generic type parameters; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.MethodBase.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.MethodBase.GetGenericArguments">
      <summary>Returns an array of <see cref="T:System.Type"></see> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that represent the type arguments of a generic method or the type parameters of a generic method definition. Returns an empty array if the current method is not a generic method.</returns>
      <exception cref="T:System.NotSupportedException">The current object is a <see cref="T:System.Reflection.ConstructorInfo"></see>. Generic constructors are not supported in the .NET Framework version 2.0. This exception is the default behavior if this method is not overridden in a derived class.</exception>
    </member>
    <member name="M:System.Reflection.MethodBase.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
      <summary>Gets method information by using the method's internal metadata representation (handle).</summary>
      <param name="handle">The method's handle.</param>
      <returns>A MethodBase containing information about the method.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="handle">handle</paramref> is invalid.</exception>
    </member>
    <member name="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
      <summary>Gets a <see cref="T:System.Reflection.MethodBase"></see> object for the constructor or method represented by the specified handle, for the specified generic type.</summary>
      <param name="handle">A handle to the internal metadata representation of a constructor or method.</param>
      <param name="declaringType">A handle to the generic type that defines the constructor or method.</param>
      <returns>A <see cref="T:System.Reflection.MethodBase"></see> object representing the method or constructor specified by <paramref name="handle">handle</paramref>, in the generic type specified by <paramref name="declaringType">declaringType</paramref>.</returns>
      <exception cref="T:System.ArgumentException"><paramref name="handle">handle</paramref> is invalid.</exception>
    </member>
    <member name="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
      <summary>When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes"></see> flags.</summary>
      <returns>The MethodImplAttributes flags.</returns>
    </member>
    <member name="M:System.Reflection.MethodBase.GetParameters">
      <summary>When overridden in a derived class, gets the parameters of the specified method or constructor.</summary>
      <returns>An array of type ParameterInfo containing information that matches the signature of the method (or constructor) reflected by this MethodBase instance.</returns>
    </member>
    <member name="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
      <summary>Invokes the method or constructor represented by the current instance, using the specified parameters.</summary>
      <param name="obj">The object on which to invoke the method or constructor. If a method is static, this argument is ignored. If a constructor is static, this argument must be null or an instance of the class that defines the constructor.</param>
      <param name="parameters">An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, parameters should be null.   If the method or constructor represented by this instance takes a ref parameter (ByRef in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function. Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is null. For value-type elements, this value is 0, 0.0, or false, depending on the specific element type.</param>
      <returns>An object containing the return value of the invoked method, or null in the case of a constructor.</returns>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception"></see> instead.  

 The <paramref name="obj">obj</paramref> parameter is null and the method is not static.   -or-   The method is not declared or inherited by the class of <paramref name="obj">obj</paramref>.   -or-   A static constructor is invoked, and <paramref name="obj">obj</paramref> is neither null nor an instance of the class that declared the constructor.</exception>
      <exception cref="T:System.ArgumentException">The elements of the <paramref name="parameters">parameters</paramref> array do not match the signature of the method or constructor reflected by this instance.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">The invoked method or constructor throws an exception.   -or-   The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod"></see> that contains unverifiable code. See the &quot;Verification&quot; section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod"></see>.</exception>
      <exception cref="T:System.Reflection.TargetParameterCountException">The <paramref name="parameters">parameters</paramref> array does not have the correct number of arguments.</exception>
      <exception cref="T:System.MethodAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 The caller does not have permission to execute the method or constructor that is represented by the current instance.</exception>
      <exception cref="T:System.InvalidOperationException">The type that declares the method is an open generic type. That is, the <see cref="P:System.Type.ContainsGenericParameters"></see> property returns true for the declaring type.</exception>
      <exception cref="T:System.NotSupportedException">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder"></see>.</exception>
    </member>
    <member name="P:System.Reflection.MethodBase.IsAbstract">
      <summary>Gets a value indicating whether the method is abstract.</summary>
      <returns>true if the method is abstract; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsAssembly">
      <summary>Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly"></see>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</summary>
      <returns>true if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsConstructor">
      <summary>Gets a value indicating whether the method is a constructor.</summary>
      <returns>true if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo"></see> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder"></see> objects); otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsFamily">
      <summary>Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family"></see>; that is, the method or constructor is visible only within its class and derived classes.</summary>
      <returns>true if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
      <summary>Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem"></see>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</summary>
      <returns>true if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
      <summary>Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem"></see>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</summary>
      <returns>true if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem"></see>; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsFinal">
      <summary>Gets a value indicating whether this method is final.</summary>
      <returns>true if this method is final; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsGenericMethod">
      <summary>Gets a value indicating whether the method is generic.</summary>
      <returns>true if the current <see cref="T:System.Reflection.MethodBase"></see> represents a generic method; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
      <summary>Gets a value indicating whether the method is a generic method definition.</summary>
      <returns>true if the current <see cref="T:System.Reflection.MethodBase"></see> object represents the definition of a generic method; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsHideBySig">
      <summary>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</summary>
      <returns>true if the member is hidden by signature; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsPrivate">
      <summary>Gets a value indicating whether this member is private.</summary>
      <returns>true if access to this method is restricted to other members of the class itself; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsPublic">
      <summary>Gets a value indicating whether this is a public method.</summary>
      <returns>true if this method is public; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsSpecialName">
      <summary>Gets a value indicating whether this method has a special name.</summary>
      <returns>true if this method has a special name; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsStatic">
      <summary>Gets a value indicating whether the method is static.</summary>
      <returns>true if this method is static; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.IsVirtual">
      <summary>Gets a value indicating whether the method is virtual.</summary>
      <returns>true if this method is virtual; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.MethodBase.MethodImplementationFlags">
      <summary>Gets the <see cref="T:System.Reflection.MethodImplAttributes"></see> flags that specify the attributes of a method implementation.</summary>
      <returns>The method implementation flags.</returns>
    </member>
    <member name="T:System.Reflection.MethodInfo">
      <summary>Discovers the attributes of a method and provides access to method metadata.</summary>
    </member>
    <member name="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
      <summary>Creates a delegate of the specified type from this method.</summary>
      <param name="delegateType">The type of the delegate to create.</param>
      <returns>The delegate for this method.</returns>
    </member>
    <member name="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
      <summary>Creates a delegate of the specified type with the specified target from this method.</summary>
      <param name="delegateType">The type of the delegate to create.</param>
      <param name="target">The object targeted by the delegate.</param>
      <returns>The delegate for this method.</returns>
    </member>
    <member name="M:System.Reflection.MethodInfo.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.MethodInfo.GetBaseDefinition">
      <summary>When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodInfo"></see> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</summary>
      <returns>A <see cref="T:System.Reflection.MethodInfo"></see> object for the first implementation of this method.</returns>
    </member>
    <member name="M:System.Reflection.MethodInfo.GetGenericArguments">
      <summary>Returns an array of <see cref="T:System.Type"></see> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that represent the type arguments of a generic method or the type parameters of a generic method definition. Returns an empty array if the current method is not a generic method.</returns>
      <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
    </member>
    <member name="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
      <summary>Returns a <see cref="T:System.Reflection.MethodInfo"></see> object that represents a generic method definition from which the current method can be constructed.</summary>
      <returns>A <see cref="T:System.Reflection.MethodInfo"></see> object representing a generic method definition from which the current method can be constructed.</returns>
      <exception cref="T:System.InvalidOperationException">The current method is not a generic method. That is, <see cref="P:System.Reflection.MethodInfo.IsGenericMethod"></see> returns false.</exception>
      <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
    </member>
    <member name="M:System.Reflection.MethodInfo.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
      <summary>Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <see cref="T:System.Reflection.MethodInfo"></see> object representing the resulting constructed method.</summary>
      <param name="typeArguments">An array of types to be substituted for the type parameters of the current generic method definition.</param>
      <returns>A <see cref="T:System.Reflection.MethodInfo"></see> object that represents the constructed method formed by substituting the elements of <paramref name="typeArguments">typeArguments</paramref> for the type parameters of the current generic method definition.</returns>
      <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Reflection.MethodInfo"></see> does not represent a generic method definition. That is, <see cref="System.Reflection.MethodInfo.IsGenericMethodDefinition"></see> returns false.</exception>
      <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments">typeArguments</paramref> is null.   -or-   Any element of <paramref name="typeArguments">typeArguments</paramref> is null.</exception>
      <exception cref="T:System.ArgumentException">The number of elements in <paramref name="typeArguments">typeArguments</paramref> is not the same as the number of type parameters of the current generic method definition.   -or-   An element of <paramref name="typeArguments">typeArguments</paramref> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</exception>
      <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
    </member>
    <member name="P:System.Reflection.MethodInfo.MemberType">
      <summary>Gets a <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a method.</summary>
      <returns>A <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a method.</returns>
    </member>
    <member name="P:System.Reflection.MethodInfo.ReturnParameter">
      <summary>Gets a <see cref="T:System.Reflection.ParameterInfo"></see> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</summary>
      <returns>A <see cref="T:System.Reflection.ParameterInfo"></see> object that contains information about the return type.</returns>
      <exception cref="T:System.NotImplementedException">This method is not implemented.</exception>
    </member>
    <member name="P:System.Reflection.MethodInfo.ReturnType">
      <summary>Gets the return type of this method.</summary>
      <returns>The return type of this method.</returns>
    </member>
    <member name="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
      <summary>Gets the custom attributes for the return type.</summary>
      <returns>An ICustomAttributeProvider object representing the custom attributes for the return type.</returns>
    </member>
    <member name="T:System.Reflection.Module">
      <summary>Performs reflection on a module.</summary>
    </member>
    <member name="P:System.Reflection.Module.Assembly">
      <summary>Gets the appropriate <see cref="T:System.Reflection.Assembly"></see> for this instance of <see cref="T:System.Reflection.Module"></see>.</summary>
      <returns>An Assembly object.</returns>
    </member>
    <member name="P:System.Reflection.Module.CustomAttributes">
      <summary>Gets a collection that contains this module's custom attributes.</summary>
      <returns>A collection that contains this module's custom attributes.</returns>
    </member>
    <member name="M:System.Reflection.Module.Equals(System.Object)">
      <summary>Determines whether this module and the specified object are equal.</summary>
      <param name="o">The object to compare with this instance.</param>
      <returns>true if <paramref name="o">o</paramref> is equal to this instance; otherwise, false.</returns>
    </member>
    <member name="F:System.Reflection.Module.FilterTypeName">
      <summary>A TypeFilter object that filters the list of types defined in this module based upon the name. This field is case-sensitive and read-only.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.Module.FilterTypeNameIgnoreCase">
      <summary>A TypeFilter object that filters the list of types defined in this module based upon the name. This field is case-insensitive and read-only.</summary>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)">
      <summary>Returns an array of classes accepted by the given filter and filter criteria.</summary>
      <param name="filter">The delegate used to filter the classes.</param>
      <param name="filterCriteria">An Object used to filter the classes.</param>
      <returns>An array of type Type containing classes that were accepted by the filter.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">One or more classes in a module could not be loaded.</exception>
    </member>
    <member name="P:System.Reflection.Module.FullyQualifiedName">
      <summary>Gets a string representing the fully qualified name and path to this module.</summary>
      <returns>The fully qualified module name.</returns>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetField(System.String)">
      <summary>Returns a field having the specified name.</summary>
      <param name="name">The field name.</param>
      <returns>A FieldInfo object having the specified name, or null if the field does not exist.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="name">name</paramref> parameter is null.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)">
      <summary>Returns a field having the specified name and binding attributes.</summary>
      <param name="name">The field name.</param>
      <param name="bindingAttr">One of the BindingFlags bit flags used to control the search.</param>
      <returns>A FieldInfo object having the specified name and binding attributes, or null if the field does not exist.</returns>
      <exception cref="T:System.ArgumentNullException">The <paramref name="name">name</paramref> parameter is null.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)">
      <summary>Returns the global fields defined on the module that match the specified binding flags.</summary>
      <param name="bindingFlags">A bitwise combination of <see cref="T:System.Reflection.BindingFlags"></see> values that limit the search.</param>
      <returns>An array of type <see cref="T:System.Reflection.FieldInfo"></see> representing the global fields defined on the module that match the specified binding flags; if no global fields match the binding flags, an empty array is returned.</returns>
    </member>
    <member name="M:System.Reflection.Module.GetFields">
      <summary>Returns the global fields defined on the module.</summary>
      <returns>An array of <see cref="T:System.Reflection.FieldInfo"></see> objects representing the global fields defined on the module; if there are no global fields, an empty array is returned.</returns>
    </member>
    <member name="M:System.Reflection.Module.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.Module.GetMethod(System.String)">
      <summary>Returns a method having the specified name.</summary>
      <param name="name">The method name.</param>
      <returns>A MethodInfo object having the specified name, or null if the method does not exist.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetMethod(System.String,System.Type[])">
      <summary>Returns a method having the specified name and parameter types.</summary>
      <param name="name">The method name.</param>
      <param name="types">The parameter types to search for.</param>
      <returns>A MethodInfo object in accordance with the specified criteria, or null if the method does not exist.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null, <paramref name="types">types</paramref> is null, or <paramref name="types">types</paramref> (i) is null.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetMethods">
      <summary>Returns the global methods defined on the module.</summary>
      <returns>An array of <see cref="T:System.Reflection.MethodInfo"></see> objects representing all the global methods defined on the module; if there are no global methods, an empty array is returned.</returns>
    </member>
    <member name="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)">
      <summary>Returns the global methods defined on the module that match the specified binding flags.</summary>
      <param name="bindingFlags">A bitwise combination of <see cref="T:System.Reflection.BindingFlags"></see> values that limit the search.</param>
      <returns>An array of type <see cref="T:System.Reflection.MethodInfo"></see> representing the global methods defined on the module that match the specified binding flags; if no global methods match the binding flags, an empty array is returned.</returns>
    </member>
    <member name="M:System.Reflection.Module.GetType(System.String)">
      <summary>Returns the specified type, performing a case-sensitive search.</summary>
      <param name="className">The name of the type to locate. The name must be fully qualified with the namespace.</param>
      <returns>A Type object representing the given type, if the type is in this module; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="className">className</paramref> is null.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">The class initializers are invoked and an exception is thrown.</exception>
      <exception cref="T:System.ArgumentException"><paramref name="className">className</paramref> is a zero-length string.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="className">className</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><paramref name="className">className</paramref> requires a dependent assembly that was found but could not be loaded.   -or-   The current assembly was loaded into the reflection-only context, and <paramref name="className">className</paramref> requires a dependent assembly that was not preloaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="className">className</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="className">className</paramref> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetType(System.String,System.Boolean)">
      <summary>Returns the specified type, searching the module with the specified case sensitivity.</summary>
      <param name="className">The name of the type to locate. The name must be fully qualified with the namespace.</param>
      <param name="ignoreCase">true for case-insensitive search; otherwise, false.</param>
      <returns>A Type object representing the given type, if the type is in this module; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="className">className</paramref> is null.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">The class initializers are invoked and an exception is thrown.</exception>
      <exception cref="T:System.ArgumentException"><paramref name="className">className</paramref> is a zero-length string.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="className">className</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><paramref name="className">className</paramref> requires a dependent assembly that was found but could not be loaded.   -or-   The current assembly was loaded into the reflection-only context, and <paramref name="className">className</paramref> requires a dependent assembly that was not preloaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="className">className</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="className">className</paramref> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)">
      <summary>Returns the specified type, specifying whether to make a case-sensitive search of the module and whether to throw an exception if the type cannot be found.</summary>
      <param name="className">The name of the type to locate. The name must be fully qualified with the namespace.</param>
      <param name="throwOnError">true to throw an exception if the type cannot be found; false to return null.</param>
      <param name="ignoreCase">true for case-insensitive search; otherwise, false.</param>
      <returns>A <see cref="T:System.Type"></see> object representing the specified type, if the type is declared in this module; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="className">className</paramref> is null.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">The class initializers are invoked and an exception is thrown.</exception>
      <exception cref="T:System.ArgumentException"><paramref name="className">className</paramref> is a zero-length string.</exception>
      <exception cref="T:System.TypeLoadException"><paramref name="throwOnError">throwOnError</paramref> is true, and the type cannot be found.</exception>
      <exception cref="T:System.IO.FileNotFoundException"><paramref name="className">className</paramref> requires a dependent assembly that could not be found.</exception>
      <exception cref="T:System.IO.FileLoadException"><paramref name="className">className</paramref> requires a dependent assembly that was found but could not be loaded.   -or-   The current assembly was loaded into the reflection-only context, and <paramref name="className">className</paramref> requires a dependent assembly that was not preloaded.</exception>
      <exception cref="T:System.BadImageFormatException"><paramref name="className">className</paramref> requires a dependent assembly, but the file is not a valid assembly.   -or-  <paramref name="className">className</paramref> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</exception>
    </member>
    <member name="M:System.Reflection.Module.GetTypes">
      <summary>Returns all the types defined within this module.</summary>
      <returns>An array of type Type containing types defined within the module that is reflected by this instance.</returns>
      <exception cref="T:System.Reflection.ReflectionTypeLoadException">One or more classes in a module could not be loaded.</exception>
      <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
    </member>
    <member name="P:System.Reflection.Module.ModuleVersionId">
      <summary>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</summary>
      <returns>A <see cref="T:System.Guid"></see> that can be used to distinguish between two versions of a module.</returns>
    </member>
    <member name="P:System.Reflection.Module.Name">
      <summary>Gets a String representing the name of the module with the path removed.</summary>
      <returns>The module name with no path.</returns>
    </member>
    <member name="P:System.Reflection.Module.ScopeName">
      <summary>Gets a string representing the name of the module.</summary>
      <returns>The module name.</returns>
    </member>
    <member name="M:System.Reflection.Module.ToString">
      <summary>Returns the name of the module.</summary>
      <returns>A String representing the name of this module.</returns>
    </member>
    <member name="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)">
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.ParameterInfo">
      <summary>Discovers the attributes of a parameter and provides access to parameter metadata.</summary>
    </member>
    <member name="P:System.Reflection.ParameterInfo.Attributes">
      <summary>Gets the attributes for this parameter.</summary>
      <returns>A ParameterAttributes object representing the attributes for this parameter.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.CustomAttributes">
      <summary>Gets a collection that contains this parameter's custom attributes.</summary>
      <returns>A collection that contains this parameter's custom attributes.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.DefaultValue">
      <summary>Gets a value indicating the default value if the parameter has a default value.</summary>
      <returns>The default value of the parameter, or <see cref="F:System.DBNull.Value"></see> if the parameter has no default value.</returns>
    </member>
    <member name="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers">
      <summary>Gets the optional custom modifiers of the parameter.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that identify the optional custom modifiers of the current parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst"></see> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced"></see>.</returns>
    </member>
    <member name="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers">
      <summary>Gets the required custom modifiers of the parameter.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that identify the required custom modifiers of the current parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst"></see> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced"></see>.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.HasDefaultValue">
      <summary>Gets a value that indicates whether this parameter has a default value.</summary>
      <returns>true if this parameter has a default value; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.IsIn">
      <summary>Gets a value indicating whether this is an input parameter.</summary>
      <returns>true if the parameter is an input parameter; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.IsOptional">
      <summary>Gets a value indicating whether this parameter is optional.</summary>
      <returns>true if the parameter is optional; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.IsOut">
      <summary>Gets a value indicating whether this is an output parameter.</summary>
      <returns>true if the parameter is an output parameter; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.IsRetval">
      <summary>Gets a value indicating whether this is a Retval parameter.</summary>
      <returns>true if the parameter is a Retval; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.Member">
      <summary>Gets a value indicating the member in which the parameter is implemented.</summary>
      <returns>The member which implanted the parameter represented by this <see cref="T:System.Reflection.ParameterInfo"></see>.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.Name">
      <summary>Gets the name of the parameter.</summary>
      <returns>The simple name of this parameter.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.ParameterType">
      <summary>Gets the Type of this parameter.</summary>
      <returns>The Type object that represents the Type of this parameter.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.Position">
      <summary>Gets the zero-based position of the parameter in the formal parameter list.</summary>
      <returns>An integer representing the position this parameter occupies in the parameter list.</returns>
    </member>
    <member name="P:System.Reflection.ParameterInfo.RawDefaultValue">
      <summary>Gets a value indicating the default value if the parameter has a default value.</summary>
      <returns>The default value of the parameter, or <see cref="F:System.DBNull.Value"></see> if the parameter has no default value.</returns>
    </member>
    <member name="M:System.Reflection.ParameterInfo.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)">
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.ParameterInfo.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.ParameterInfo.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)">
      <param name="attributeType"></param>
      <param name="inherit"></param>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.ParameterModifier">
      <summary>Attaches a modifier to parameters so that binding can work with parameter signatures in which the types have been modified.</summary>
    </member>
    <member name="M:System.Reflection.ParameterModifier.#ctor(System.Int32)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.ParameterModifier"></see> structure representing the specified number of parameters.</summary>
      <param name="parameterCount">The number of parameters.</param>
      <exception cref="T:System.ArgumentException"><paramref name="parameterCount">parameterCount</paramref> is negative.</exception>
    </member>
    <member name="P:System.Reflection.ParameterModifier.Item(System.Int32)">
      <summary>Gets or sets a value that specifies whether the parameter at the specified index position is to be modified by the current <see cref="T:System.Reflection.ParameterModifier"></see>.</summary>
      <param name="index">The index position of the parameter whose modification status is being examined or set.</param>
      <returns>true if the parameter at this index position is to be modified by this <see cref="T:System.Reflection.ParameterModifier"></see>; otherwise, false.</returns>
    </member>
    <member name="T:System.Reflection.PropertyInfo">
      <summary>Discovers the attributes of a property and provides access to property metadata.</summary>
    </member>
    <member name="P:System.Reflection.PropertyInfo.Attributes">
      <summary>Gets the attributes for this property.</summary>
      <returns>The attributes of this property.</returns>
    </member>
    <member name="P:System.Reflection.PropertyInfo.CanRead">
      <summary>Gets a value indicating whether the property can be read.</summary>
      <returns>true if this property can be read; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.PropertyInfo.CanWrite">
      <summary>Gets a value indicating whether the property can be written to.</summary>
      <returns>true if this property can be written to; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.Equals(System.Object)">
      <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      <param name="obj">An object to compare with this instance, or null.</param>
      <returns>true if <paramref name="obj">obj</paramref> equals the type and value of this instance; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetAccessors">
      <summary>Returns an array whose elements reflect the public get and set accessors of the property reflected by the current instance.</summary>
      <returns>An array of <see cref="T:System.Reflection.MethodInfo"></see> objects that reflect the public get and set accessors of the property reflected by the current instance, if found; otherwise, this method returns an array with zero (0) elements.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetAccessors(System.Boolean)">
      <summary>Returns an array whose elements reflect the public and, if specified, non-public get and set accessors of the property reflected by the current instance.</summary>
      <param name="nonPublic">Indicates whether non-public methods should be returned in the returned array. true if non-public methods are to be included; otherwise, false.</param>
      <returns>An array whose elements reflect the get and set accessors of the property reflected by the current instance. If <paramref name="nonPublic">nonPublic</paramref> is true, this array contains public and non-public get and set accessors. If <paramref name="nonPublic">nonPublic</paramref> is false, this array contains only public get and set accessors. If no accessors with the specified visibility are found, this method returns an array with zero (0) elements.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetConstantValue">
      <summary>Returns a literal value associated with the property by a compiler.</summary>
      <returns>An <see cref="T:System.Object"></see> that contains the literal value associated with the property. If the literal value is a class type with an element value of zero, the return value is null.</returns>
      <exception cref="T:System.InvalidOperationException">The Constant table in unmanaged metadata does not contain a constant value for the current property.</exception>
      <exception cref="T:System.FormatException">The type of the value is not one of the types permitted by the Common Language Specification (CLS). See the ECMA Partition II specification, Metadata.</exception>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetGetMethod">
      <summary>Returns the public get accessor for this property.</summary>
      <returns>A MethodInfo object representing the public get accessor for this property, or null if the get accessor is non-public or does not exist.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetGetMethod(System.Boolean)">
      <summary>When overridden in a derived class, returns the public or non-public get accessor for this property.</summary>
      <param name="nonPublic">Indicates whether a non-public get accessor should be returned. true if a non-public accessor is to be returned; otherwise, false.</param>
      <returns>A MethodInfo object representing the get accessor for this property, if <paramref name="nonPublic">nonPublic</paramref> is true. Returns null if <paramref name="nonPublic">nonPublic</paramref> is false and the get accessor is non-public, or if <paramref name="nonPublic">nonPublic</paramref> is true but no get accessors exist.</returns>
      <exception cref="T:System.Security.SecurityException">The requested method is non-public and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission"></see> to reflect on this non-public method.</exception>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetHashCode">
      <summary>Returns the hash code for this instance.</summary>
      <returns>A 32-bit signed integer hash code.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetIndexParameters">
      <summary>When overridden in a derived class, returns an array of all the index parameters for the property.</summary>
      <returns>An array of type ParameterInfo containing the parameters for the indexes. If the property is not indexed, the array has 0 (zero) elements.</returns>
    </member>
    <member name="P:System.Reflection.PropertyInfo.GetMethod">
      <summary>Gets the get accessor for this property.</summary>
      <returns>The get accessor for this property.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetOptionalCustomModifiers">
      <summary>Returns an array of types representing the optional custom modifiers of the property.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that identify the optional custom modifiers of the current property, such as <see cref="T:System.Runtime.CompilerServices.IsConst"></see> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced"></see>.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetRawConstantValue">
      <summary>Returns a literal value associated with the property by a compiler.</summary>
      <returns>An <see cref="T:System.Object"></see> that contains the literal value associated with the property. If the literal value is a class type with an element value of zero, the return value is null.</returns>
      <exception cref="T:System.InvalidOperationException">The Constant table in unmanaged metadata does not contain a constant value for the current property.</exception>
      <exception cref="T:System.FormatException">The type of the value is not one of the types permitted by the Common Language Specification (CLS). See the ECMA Partition II specification, Metadata Logical Format: Other Structures, Element Types used in Signatures.</exception>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetRequiredCustomModifiers">
      <summary>Returns an array of types representing the required custom modifiers of the property.</summary>
      <returns>An array of <see cref="T:System.Type"></see> objects that identify the required custom modifiers of the current property, such as <see cref="T:System.Runtime.CompilerServices.IsConst"></see> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced"></see>.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetSetMethod(System.Boolean)">
      <summary>When overridden in a derived class, returns the set accessor for this property.</summary>
      <param name="nonPublic">Indicates whether the accessor should be returned if it is non-public. true if a non-public accessor is to be returned; otherwise, false.</param>
      <returns><p sourcefile="System.Reflection.yml" sourcestartlinenumber="1" sourceendlinenumber="2"><p sourcefile="System.Reflection.yml" sourcestartlinenumber="1" sourceendlinenumber="1">This property&amp;#39;s <code>Set</code> method, or <code>null</code>, as shown in the following table.  </p>
 <table><thead><tr><th> Value  <p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="4" sourceendlinenumber="4"> </th><th> Condition  <p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="6" sourceendlinenumber="6"> </th></tr></thead><tbody><tr><td> The <code>Set</code> method for this property.  <p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="8" sourceendlinenumber="8"> </td><td> The <code>set</code> accessor is public.  <p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="10" sourceendlinenumber="10"> -or-  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="12" sourceendlinenumber="12"> <code data-dev-comment-type="paramref">nonPublic</code> is <code>true</code> and the <code>set</code> accessor is non-public.  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="14" sourceendlinenumber="14"> </td></tr><tr><td><code>null</code></td><td><code data-dev-comment-type="paramref">nonPublic</code> is <code>true</code>, but the property is read-only.  <p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="16" sourceendlinenumber="16"> -or-  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="18" sourceendlinenumber="18"> <code data-dev-comment-type="paramref">nonPublic</code> is <code>false</code> and the <code>set</code> accessor is non-public.  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="20" sourceendlinenumber="20"> -or-  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="22" sourceendlinenumber="22"> There is no <code>set</code> accessor.  </p>
<p sourcefile="System.Reflection.yml" sourcestartlinenumber="24" sourceendlinenumber="24"> </td></tr></tbody></table></p>
</returns>
      <exception cref="T:System.Security.SecurityException">The requested method is non-public and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission"></see> to reflect on this non-public method.</exception>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetSetMethod">
      <summary>Returns the public set accessor for this property.</summary>
      <returns>The MethodInfo object representing the Set method for this property if the set accessor is public, or null if the set accessor is not public.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetValue(System.Object)">
      <summary>Returns the property value of a specified object.</summary>
      <param name="obj">The object whose property value will be returned.</param>
      <returns>The property value of the specified object.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.GetValue(System.Object,System.Object[])">
      <summary>Returns the property value of a specified object with optional index values for indexed properties.</summary>
      <param name="obj">The object whose property value will be returned.</param>
      <param name="index">Optional index values for indexed properties. The indexes of indexed properties are zero-based. This value should be null for non-indexed properties.</param>
      <returns>The property value of the specified object.</returns>
      <exception cref="T:System.ArgumentException">The <paramref name="index">index</paramref> array does not contain the type of arguments needed.   -or-   The property's get accessor is not found.</exception>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception"></see> instead.  

 The object does not match the target type, or a property is an instance property but <paramref name="obj">obj</paramref> is null.</exception>
      <exception cref="T:System.Reflection.TargetParameterCountException">The number of parameters in <paramref name="index">index</paramref> does not match the number of parameters the indexed property takes.</exception>
      <exception cref="T:System.MethodAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 There was an illegal attempt to access a private or protected method inside a class.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while retrieving the property value. For example, an index value specified for an indexed property is out of range. The <see cref="P:System.Exception.InnerException"></see> property indicates the reason for the error.</exception>
    </member>
    <member name="P:System.Reflection.PropertyInfo.IsSpecialName">
      <summary>Gets a value indicating whether the property is the special name.</summary>
      <returns>true if this property is the special name; otherwise, false.</returns>
    </member>
    <member name="P:System.Reflection.PropertyInfo.MemberType">
      <summary>Gets a <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a property.</summary>
      <returns>A <see cref="T:System.Reflection.MemberTypes"></see> value indicating that this member is a property.</returns>
    </member>
    <member name="P:System.Reflection.PropertyInfo.PropertyType">
      <summary>Gets the type of this property.</summary>
      <returns>The type of this property.</returns>
    </member>
    <member name="P:System.Reflection.PropertyInfo.SetMethod">
      <summary>Gets the set accessor for this property.</summary>
      <returns>The set accessor for this property, or null if the property is read-only.</returns>
    </member>
    <member name="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object)">
      <summary>Sets the property value of a specified object.</summary>
      <param name="obj">The object whose property value will be set.</param>
      <param name="value">The new property value.</param>
      <exception cref="T:System.ArgumentException">The property's set accessor is not found.   -or-  <paramref name="value">value</paramref> cannot be converted to the type of <see cref="P:System.Reflection.PropertyInfo.PropertyType"></see>.</exception>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception"></see> instead.  

 The type of <paramref name="obj">obj</paramref> does not match the target type, or a property is an instance property but <paramref name="obj">obj</paramref> is null.</exception>
      <exception cref="T:System.MethodAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 There was an illegal attempt to access a private or protected method inside a class.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while setting the property value. The <see cref="P:System.Exception.InnerException"></see> property indicates the reason for the error.</exception>
    </member>
    <member name="M:System.Reflection.PropertyInfo.SetValue(System.Object,System.Object,System.Object[])">
      <summary>Sets the property value of a specified object with optional index values for index properties.</summary>
      <param name="obj">The object whose property value will be set.</param>
      <param name="value">The new property value.</param>
      <param name="index">Optional index values for indexed properties. This value should be null for non-indexed properties.</param>
      <exception cref="T:System.ArgumentException">The <paramref name="index">index</paramref> array does not contain the type of arguments needed.   -or-   The property's set accessor is not found.   -or-  <paramref name="value">value</paramref> cannot be converted to the type of <see cref="P:System.Reflection.PropertyInfo.PropertyType"></see>.</exception>
      <exception cref="T:System.Reflection.TargetException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception"></see> instead.  

 The object does not match the target type, or a property is an instance property but <paramref name="obj">obj</paramref> is null.</exception>
      <exception cref="T:System.Reflection.TargetParameterCountException">The number of parameters in <paramref name="index">index</paramref> does not match the number of parameters the indexed property takes.</exception>
      <exception cref="T:System.MethodAccessException">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException"></see>, instead.  

 There was an illegal attempt to access a private or protected method inside a class.</exception>
      <exception cref="T:System.Reflection.TargetInvocationException">An error occurred while setting the property value. For example, an index value specified for an indexed property is out of range. The <see cref="P:System.Exception.InnerException"></see> property indicates the reason for the error.</exception>
    </member>
    <member name="T:System.Reflection.ReflectionContext">
      <summary>Represents a context that can provide reflection objects.</summary>
    </member>
    <member name="M:System.Reflection.ReflectionContext.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.ReflectionContext"></see> class.</summary>
    </member>
    <member name="M:System.Reflection.ReflectionContext.GetTypeForObject(System.Object)">
      <summary>Gets the representation of the type of the specified object in this reflection context.</summary>
      <param name="value">The object to represent.</param>
      <returns>An object that represents the type of the specified object.</returns>
    </member>
    <member name="M:System.Reflection.ReflectionContext.MapAssembly(System.Reflection.Assembly)">
      <summary>Gets the representation, in this reflection context, of an assembly that is represented by an object from another reflection context.</summary>
      <param name="assembly">The external representation of the assembly to represent in this context.</param>
      <returns>The representation of the assembly in this reflection context.</returns>
    </member>
    <member name="M:System.Reflection.ReflectionContext.MapType(System.Reflection.TypeInfo)">
      <summary>Gets the representation, in this reflection context, of a type represented by an object from another reflection context.</summary>
      <param name="type">The external representation of the type to represent in this context.</param>
      <returns>The representation of the type in this reflection context..</returns>
    </member>
    <member name="T:System.Reflection.ReflectionTypeLoadException">
      <summary>The exception that is thrown by the <see cref="M:System.Reflection.Module.GetTypes"></see> method if any of the classes in a module cannot be loaded. This class cannot be inherited.</summary>
    </member>
    <member name="M:System.Reflection.ReflectionTypeLoadException.#ctor(System.Type[],System.Exception[])">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.ReflectionTypeLoadException"></see> class with the given classes and their associated exceptions.</summary>
      <param name="classes">An array of type Type containing the classes that were defined in the module and loaded. This array can contain null reference (Nothing in Visual Basic) values.</param>
      <param name="exceptions">An array of type Exception containing the exceptions that were thrown by the class loader. The null reference (Nothing in Visual Basic) values in the classes array line up with the exceptions in this exceptions array.</param>
    </member>
    <member name="M:System.Reflection.ReflectionTypeLoadException.#ctor(System.Type[],System.Exception[],System.String)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.ReflectionTypeLoadException"></see> class with the given classes, their associated exceptions, and exception descriptions.</summary>
      <param name="classes">An array of type Type containing the classes that were defined in the module and loaded. This array can contain null reference (Nothing in Visual Basic) values.</param>
      <param name="exceptions">An array of type Exception containing the exceptions that were thrown by the class loader. The null reference (Nothing in Visual Basic) values in the classes array line up with the exceptions in this exceptions array.</param>
      <param name="message">A String describing the reason the exception was thrown.</param>
    </member>
    <member name="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions">
      <summary>Gets the array of exceptions thrown by the class loader.</summary>
      <returns>An array of type Exception containing the exceptions thrown by the class loader. The null values in the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types"></see> array of this instance line up with the exceptions in this array.</returns>
    </member>
    <member name="P:System.Reflection.ReflectionTypeLoadException.Types">
      <summary>Gets the array of classes that were defined in the module and loaded.</summary>
      <returns>An array of type Type containing the classes that were defined in the module and loaded. This array can contain some null values.</returns>
    </member>
    <member name="T:System.Reflection.ResourceLocation">
      <summary>Specifies the resource location.</summary>
    </member>
    <member name="F:System.Reflection.ResourceLocation.ContainedInAnotherAssembly">
      <summary>Specifies that the resource is contained in another assembly.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.ResourceLocation.ContainedInManifestFile">
      <summary>Specifies that the resource is contained in the manifest file.</summary>
      <returns></returns>
    </member>
    <member name="F:System.Reflection.ResourceLocation.Embedded">
      <summary>Specifies an embedded (that is, non-linked) resource.</summary>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.TargetException">
      <summary>Represents the exception that is thrown when an attempt is made to invoke an invalid target.</summary>
    </member>
    <member name="M:System.Reflection.TargetException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetException"></see> class with an empty message and the root cause of the exception.</summary>
    </member>
    <member name="M:System.Reflection.TargetException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetException"></see> class with the given message and the root cause exception.</summary>
      <param name="message">A String describing the reason why the exception occurred.</param>
    </member>
    <member name="M:System.Reflection.TargetException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetException"></see> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="inner">The exception that is the cause of the current exception. If the inner parameter is not null, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="T:System.Reflection.TargetInvocationException">
      <summary>The exception that is thrown by methods invoked through reflection. This class cannot be inherited.</summary>
    </member>
    <member name="M:System.Reflection.TargetInvocationException.#ctor(System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetInvocationException"></see> class with a reference to the inner exception that is the cause of this exception.</summary>
      <param name="inner">The exception that is the cause of the current exception. If the inner parameter is not null, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="M:System.Reflection.TargetInvocationException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetInvocationException"></see> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="inner">The exception that is the cause of the current exception. If the inner parameter is not null, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="T:System.Reflection.TargetParameterCountException">
      <summary>The exception that is thrown when the number of parameters for an invocation does not match the number expected. This class cannot be inherited.</summary>
    </member>
    <member name="M:System.Reflection.TargetParameterCountException.#ctor">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetParameterCountException"></see> class with an empty message string and the root cause of the exception.</summary>
    </member>
    <member name="M:System.Reflection.TargetParameterCountException.#ctor(System.String)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetParameterCountException"></see> class with its message string set to the given message and the root cause exception.</summary>
      <param name="message">A String describing the reason this exception was thrown.</param>
    </member>
    <member name="M:System.Reflection.TargetParameterCountException.#ctor(System.String,System.Exception)">
      <summary>Initializes a new instance of the <see cref="T:System.Reflection.TargetParameterCountException"></see> class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="inner">The exception that is the cause of the current exception. If the inner parameter is not null, the current exception is raised in a catch block that handles the inner exception.</param>
    </member>
    <member name="T:System.Reflection.TypeFilter">
      <summary>Filters the classes represented in an array of <see cref="T:System.Type"></see> objects.</summary>
      <param name="m">The Type object to which the filter is applied.</param>
      <param name="filterCriteria">An arbitrary object used to filter the list.</param>
      <returns></returns>
    </member>
    <member name="T:System.Reflection.TypeInfo">
      <summary>Represents type declarations for class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</summary>
    </member>
    <member name="P:System.Reflection.TypeInfo.Assembly">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.AssemblyQualifiedName">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.AsType">
      <summary>Returns the current type as a <see cref="T:System.Type"></see> object.</summary>
      <returns>The current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.Attributes">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.BaseType">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.ContainsGenericParameters">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaredConstructors">
      <summary>Gets a collection of the constructors declared by the current type.</summary>
      <returns>A collection of the constructors declared by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaredEvents">
      <summary>Gets a collection of the events defined by the current type.</summary>
      <returns>A collection of the events defined by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaredFields">
      <summary>Gets a collection of the fields defined by the current type.</summary>
      <returns>A collection of the fields defined by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaredMembers">
      <summary>Gets a collection of the members defined by the current type.</summary>
      <returns>A collection of the members defined by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaredMethods">
      <summary>Gets a collection of the methods defined by the current type.</summary>
      <returns>A collection of the methods defined by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaredNestedTypes">
      <summary>Gets a collection of the nested types defined by the current type.</summary>
      <returns>A collection of nested types defined by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaredProperties">
      <summary>Gets a collection of the properties defined by the current type.</summary>
      <returns>A collection of the properties defined by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.DeclaringMethod">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
      <param name="filter"></param>
      <param name="filterCriteria"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
      <param name="memberType"></param>
      <param name="bindingAttr"></param>
      <param name="filter"></param>
      <param name="filterCriteria"></param>
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.FullName">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.GenericParameterAttributes">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.GenericParameterPosition">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.GenericTypeArguments">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.GenericTypeParameters">
      <summary>Gets an array of the generic type parameters of the current instance.</summary>
      <returns>An array that contains the current instance's generic type parameters, or an array of <see cref="P:System.Array.Length"></see> zero if the current instance has no generic type parameters.</returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetArrayRank">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetConstructor(System.Type[])">
      <param name="types"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetConstructors">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetConstructors(System.Reflection.BindingFlags)">
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetDeclaredEvent(System.String)">
      <summary>Returns an object that represents the specified public event declared by the current type.</summary>
      <param name="name">The name of the event.</param>
      <returns>An object that represents the specified event, if found; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetDeclaredField(System.String)">
      <summary>Returns an object that represents the specified public field declared by the current type.</summary>
      <param name="name">The name of the field.</param>
      <returns>An object that represents the specified field, if found; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetDeclaredMethod(System.String)">
      <summary>Returns an object that represents the specified public method declared by the current type.</summary>
      <param name="name">The name of the method.</param>
      <returns>An object that represents the specified method, if found; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetDeclaredMethods(System.String)">
      <summary>Returns a collection that contains all public methods declared on the current type that match the specified name.</summary>
      <param name="name">The method name to search for.</param>
      <returns>A collection that contains methods that match <paramref name="name">name</paramref>.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetDeclaredNestedType(System.String)">
      <summary>Returns an object that represents the specified public nested type declared by the current type.</summary>
      <param name="name">The name of the nested type.</param>
      <returns>An object that represents the specified nested type, if found; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetDeclaredProperty(System.String)">
      <summary>Returns an object that represents the specified public property declared by the current type.</summary>
      <param name="name">The name of the property.</param>
      <returns>An object that represents the specified property, if found; otherwise, null.</returns>
      <exception cref="T:System.ArgumentNullException"><paramref name="name">name</paramref> is null.</exception>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetDefaultMembers">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetElementType">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEnumName(System.Object)">
      <param name="value"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEnumNames">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEnumUnderlyingType">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEnumValues">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEvent(System.String)">
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEvent(System.String,System.Reflection.BindingFlags)">
      <param name="name"></param>
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEvents">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetEvents(System.Reflection.BindingFlags)">
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetField(System.String)">
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetField(System.String,System.Reflection.BindingFlags)">
      <param name="name"></param>
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetFields">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetFields(System.Reflection.BindingFlags)">
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetGenericArguments">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetGenericParameterConstraints">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetGenericTypeDefinition">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetInterface(System.String)">
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetInterface(System.String,System.Boolean)">
      <param name="name"></param>
      <param name="ignoreCase"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetInterfaces">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMember(System.String)">
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMember(System.String,System.Reflection.BindingFlags)">
      <param name="name"></param>
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
      <param name="name"></param>
      <param name="type"></param>
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMembers">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMembers(System.Reflection.BindingFlags)">
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMethod(System.String)">
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMethod(System.String,System.Reflection.BindingFlags)">
      <param name="name"></param>
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMethod(System.String,System.Type[])">
      <param name="name"></param>
      <param name="types"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
      <param name="name"></param>
      <param name="types"></param>
      <param name="modifiers"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMethods">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetMethods(System.Reflection.BindingFlags)">
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetNestedType(System.String,System.Reflection.BindingFlags)">
      <param name="name"></param>
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetNestedType(System.String)">
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetNestedTypes">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetNestedTypes(System.Reflection.BindingFlags)">
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperties">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperties(System.Reflection.BindingFlags)">
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperty(System.String)">
      <param name="name"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperty(System.String,System.Reflection.BindingFlags)">
      <param name="name"></param>
      <param name="bindingAttr"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperty(System.String,System.Type)">
      <param name="name"></param>
      <param name="returnType"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperty(System.String,System.Type[])">
      <param name="name"></param>
      <param name="types"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperty(System.String,System.Type,System.Type[])">
      <param name="name"></param>
      <param name="returnType"></param>
      <param name="types"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
      <param name="name"></param>
      <param name="returnType"></param>
      <param name="types"></param>
      <param name="modifiers"></param>
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.GUID">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.HasElementType">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.ImplementedInterfaces">
      <summary>Gets a collection of the interfaces implemented by the current type.</summary>
      <returns>A collection of the interfaces implemented by the current type.</returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsAbstract">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsAnsiClass">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsArray">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.IsAssignableFrom(System.Reflection.TypeInfo)">
      <summary>Returns a value that indicates whether the specified type can be assigned to the current type.</summary>
      <param name="typeInfo">The type to check.</param>
      <returns>true if the specified type can be assigned to this type; otherwise, false.</returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.IsAssignableFrom(System.Type)">
      <param name="c"></param>
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsAutoClass">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsAutoLayout">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsByRef">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsClass">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsCOMObject">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsEnum">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.IsEnumDefined(System.Object)">
      <param name="value"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.IsEquivalentTo(System.Type)">
      <param name="other"></param>
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsExplicitLayout">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsGenericParameter">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsGenericType">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsGenericTypeDefinition">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsImport">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.IsInstanceOfType(System.Object)">
      <param name="o"></param>
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsInterface">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsLayoutSequential">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsMarshalByRef">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNested">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNestedAssembly">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNestedFamANDAssem">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNestedFamily">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNestedFamORAssem">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNestedPrivate">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNestedPublic">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsNotPublic">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsPointer">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsPrimitive">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsPublic">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsSealed">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsSerializable">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsSpecialName">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.IsSubclassOf(System.Type)">
      <param name="c"></param>
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsUnicodeClass">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsValueType">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.IsVisible">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.MakeArrayType">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.MakeArrayType(System.Int32)">
      <param name="rank"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.MakeByRefType">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.MakeGenericType(System.Type[])">
      <param name="typeArguments"></param>
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.MakePointerType">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.MemberType">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.Namespace">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.StructLayoutAttribute">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.TypeInitializer">
      <returns></returns>
    </member>
    <member name="P:System.Reflection.TypeInfo.UnderlyingSystemType">
      <returns></returns>
    </member>
    <member name="M:System.Reflection.TypeInfo.System#Reflection#IReflectableType#GetTypeInfo">
      <summary>Returns a representation of the current type as a <see cref="T:System.Reflection.TypeInfo"></see> object.</summary>
      <returns>A reference to the current type.</returns>
    </member>
  </members>
</doc></span>